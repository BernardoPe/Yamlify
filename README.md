# Yamlify

Yamlify is a simplified YAML-to-object parsing library for the JVM (Kotlin) focused on constructor-based object creation and on
comparing two instantiation strategies: reflection and runtime bytecode generation. Both strategies share the same YAML
front-end (text parsing) and differ only in how the final domain objects are instantiated.

## Project structure1

This repository is a multi-module Gradle build. The `yamlify` module contains the core library. The `yamlify-bench`
module contains JMH benchmarks used to compare parser strategies.

## Features

Yamlify parses a restricted, indentation-driven subset of YAML into Kotlin objects. It supports parsing a single object,
a YAML list of objects, and a lazy sequence of objects. It also provides convenience methods to parse all `.yaml` files
from a folder, either eagerly or lazily.

Object construction is constructor-oriented. The parser builds a map from YAML keys to constructor parameter values,
supports nested objects and lists, and can handle Kotlin default parameters. The library supports mapping YAML keys to
different constructor parameter names and supports custom value conversion via annotations.

## Public API

The public abstraction is the `YamlParser<T>` interface:

```kotlin
interface YamlParser<T> {
    fun parseObject(yaml: Reader): T
    fun parseList(yaml: Reader): List<T>
    fun parseSequence(yaml: Reader): Sequence<T>
    fun parseFolderEager(folder: String): List<T>
    fun parseFolderLazy(folder: String): Sequence<T>
}
```

In practice you obtain a parser for a target type by using either `YamlParserReflect.yamlParser(...)` or
`YamlParserCojen.yamlParser(...)`.

## Design and implementation

`AbstractYamlParser<T>` implements the YAML front-end. It parses the input text into a tree made of maps and lists,
using indentation and list markers (`-`) to describe structure. Scalar values are preserved as strings during parsing
and only converted to their target types during object instantiation.

The core parsing operations (`parseObject`, `parseList`, `parseSequence`, and the folder helpers) are implemented in
`AbstractYamlParser<T>`. The class delegates object creation to `newInstance(args: Map<String, Any>)`, which is
implemented by the chosen instantiation strategy.

`YamlParserReflect` implements instantiation with Kotlin reflection. It inspects the constructor, builds a mapping from
YAML property names to constructor parameters, and precomputes conversion functions for each constructor parameter. On
each parse, it constructs the argument map and invokes the constructor via `callBy()`. Parser instances are cached per
target type.

`YamlParserCojen` implements instantiation by generating a specialized parser class at runtime with Cojen Maker. The
generated class overrides `newInstance` and contains direct code to read values from the argument map, validate missing
and duplicate parameters, convert primitive types, instantiate nested objects, and build lists. The generation happens
on first use and the resulting parser is cached, so subsequent parses run generated bytecode and avoid reflective
constructor calls.

## Annotations and custom conversion

### `@YamlArg`

`@YamlArg` binds a constructor parameter to a YAML key with a different name.

```kotlin
class Student(
    val name: String,
    @YamlArg("city of birth")
    val from: String
)
```

YAML:

```yaml
name: Maria
city of birth: Lisbon
```

### `@YamlConvert`

`@YamlConvert` constructs a constructor parameter from a scalar string via a converter.

```kotlin
class Student(
    val name: String,
    @YamlConvert(YamlToDate::class)
    val birth: LocalDate
)

class YamlToDate : YamlConverter<LocalDate> {
    override fun convertToObject(input: String): LocalDate = LocalDate.parse(input)
}
```

YAML:

```yaml
name: Maria
birth: 2000-05-15
```

## Usage

### Parse a single object

```kotlin
val parser = YamlParserReflect.yamlParser(Student::class)
val student = parser.parseObject(yamlString.reader())

val fastParser = YamlParserCojen.yamlParser(Student::class)
val student2 = fastParser.parseObject(yamlString.reader())
```

### Parse a list

```kotlin
val yaml = """
  -
    name: John
    nr: 12345
    from: Porto
  -
    name: Maria
    nr: 67890
    from: Lisbon
"""

val parser = YamlParserReflect.yamlParser(Student::class)
val students = parser.parseList(yaml.reader())
```

### Parse lazily with sequences

```kotlin
val parser = YamlParserCojen.yamlParser(Student::class)
val students: Sequence<Student> = parser.parseSequence(yamlFile.reader())

students
    .filter { it.nr > 50000 }
    .take(10)
    .forEach { println(it.name) }
```

### Parse all YAML files in a folder

```kotlin
val parser = YamlParserReflect.yamlParser(Student::class)

val allStudents = parser.parseFolderEager("./students")
val lazyStudents = parser.parseFolderLazy("./students")
```

## Benchmarks

### Methodology

Benchmarks are implemented with JMH in the `yamlify-bench` module. The command used to produce the results below was run
with 10 measurement iterations of 2 seconds each and 4 warmup iterations. The benchmark compares a hand-written baseline
parser dedicated to the benchmark domain class, `YamlParserCojen`, and `YamlParserReflect`. The baseline parser uses
direct constructor calls and primitive type conversions without reflection or code generation.

The results included in this repository were obtained on a machine with an AMD Ryzen 5 5600 CPU and 16GB 3200MHz RAM.

### Savings Account benchmark

The Savings Account benchmark uses a flat domain class with only primitive and string fields:

```kotlin
class SavingsAccount(
    val accountCode: Short,
    val holderName: String,
    val balance: Long,
    val isActive: Boolean,
    val interestRate: Double,
    val transactionLimit: Int,
    val withdrawLimit: Int
)
```

| Parser   | Operations per millisecond | Relative performance |
|----------|----------------------------|----------------------|
| Baseline | 521.963 ± 1.463            | 1.000                |
| Cojen    | 514.603 ± 1.589            | 0.986                |
| Reflect  | 436.399 ± 0.837            | 0.836                |

For this flat structure, the Cojen-based parser performs within the margin of the baseline because it executes generated
code after an initial, one-time generation step. The reflective approach is slower because each parsed instance requires
reflective constructor invocation (`callBy()`), and that overhead remains on the hot path.

### Student benchmark

The Student benchmark uses a more complex object graph, with a nested object and a list of nested objects:

```kotlin
class Student(
    val name: String,
    val nr: Int,
    val from: String,
    val address: Address? = null,
    val grades: List<Grade> = emptyList()
)

class Grade(val subject: String, val classification: Int)
class Address(val street: String, val number: Int, val city: String)
```

| Parser   | Operations per millisecond | Relative performance |
|----------|----------------------------|----------------------|
| Baseline | 306.275 ± 1.646            | 1.000                |
| Cojen    | 301.828 ± 0.678            | 0.985                |
| Reflect  | 231.036 ± 0.485            | 0.754                |

The Cojen approach remains close to the baseline because the additional work (building nested objects and lists) is
expressed as direct code in the generated parser. The reflective approach loses more ground on this benchmark because
nested instantiation amplifies reflective overhead: the parser performs multiple reflective constructor calls per
`Student` (for the nested `Address` and for each `Grade`).

## Building, testing, and running benchmarks

The build uses the Gradle wrapper and configures a Java 21 toolchain in the module builds.

To build the project:

```bash
./gradlew build
```

To run the unit tests:

```bash
./gradlew test
```

To run the benchmarks:

```bash
./gradlew jmhJar
java -jar yamlify-bench/build/libs/yamlify-bench-jmh.jar -i 10 -wi 4 -f 1 -r 2 -w 2 -tu ms
```

## Dependencies

The core module depends on `kotlin-reflect` and `org.cojen:cojen-maker`. The benchmark module applies the JMH Gradle
plugin and depends on the core module.
